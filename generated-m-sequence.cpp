/*
Написать программу генерации m - последовательностей 0 и 1, удовлетворяющих обоим требованиям :

1) число единиц должно быть нечётно(включая 0 единиц);

2) число нулей должно быть меньше числа единиц. (читать как число едениц больше числа нулей)

*/

/*
Немного сути:

***** Как сказано в методичке: *****
Генерация m-последовательностей 0 и 1.

Для решения можно использовать алгоритм генерации размещений с повторениями, где xi = 0 и yi = 1.

Однако если в условии задано ограничение на количество 0 или 1, то при таком подходе заведомо будут генерироваться лишние последовательности.
В этом случае лучше использовать алгоритм генерации сочетаний без повторений для номеров мест, на которые будут расставляться 0 или 1.
При получении каждой сгенерированной комбинации номеров мест для 1 (0) в массиве С, нужно обнулить (заполнить 1) массив А требуемых m-последовательностей,
а затем расставить в нём на места из массива С единицы (нули).

***** Что я делаю: *****
Есть функция Sochet_BP, которая будет генерировать места на которые расставляем 1.
Они представляют собой массив с номерами, на которые расставляем 1.
После генерации очередного такого массива, вызывается функция CreateSequence,
которая создает конечную последовательность 0 и 1 и вызывает функцию для печати ее на экран.
Последовательноть создается очень просто:
На вход был подан массив с позициями для 1
Просто создаем массив длиной m (длина последовательности) и на места,
указаные во входном массиве ставим 1
Потом просто выводим этот массив на экран

Чтобы последовательноть подходила под условия:
1) число единиц должно быть нечётно(включая 0 единиц);
2) число нулей должно быть меньше числа единиц. (читать как число единиц больше числа нулей)

Будем делать следующее в функции main:
m - длина последовательности
В цикле for:
n - кол-во едениц в конечной последовательности
Чтобы оно удовлетворяло условию 2, нужно чтобы число единиц (то есть переменная n) была больше половины всей последовательности
Поэтому цикл начинается с n = m / 2 + 1 и идет до m
Чтобы оно удовлетворяло условию 1, перед вызовом функции Sochet_BP проверяем условие n % 2 != 0, которое выполнится,
если чило n - нечетное (то, что нам и нужно)

*/

#include <iostream>

using namespace std;

void GeneratedSequence(int m);
void Sochet_BP(int k, int n, int* A, bool* dop, int m);

int main()
{
	setlocale(LC_ALL, "Russian");

	cout << "Сгенерированные последовательности:" << endl;

	GeneratedSequence(11);

	system("pause");
}

// Генерация последовательности.
// параметры:
// m - длина последовательности.
void GeneratedSequence(int m)
{
	// Бежим по циклу, начиная с половины длины последовательности, чтобы кол-во 1 было больше 0 (по условию задачи)
	// n - кол-во мест для размещения еденичек
	// Чтобы построить все последовательности 0 и 1 удовлетворяющих условию, 
	// нужно выполнить функцию генерации мест для размещения 1 для всего возможного количества единичек, удовлетворяющего условию
	for (int n = m / 2 + 1; n <= m; n++)
	{
		int* A = new int[n]; // массив позиций для размещения 1
		bool* dop = new bool[n]; // массив отвечающий,  доступно ли число в строящейся последовательности или нет (true - доступно, false - недоступно)

		for (int i = 0; i < n; i++)
			dop[i] = true; // заполняем dop значением true (все числа изначальны доступны)

		if (n % 2 != 0) // если кол-во единичек нечетно - то выполнить алгоритм по поиску мест для 1
			Sochet_BP(0, n, A, dop, m);
	}
}

// Вывод массива.
// параметры:
// mass - массив для вывода.
// length - длина массива.
void Print(int* mass, int length)
{
	for (int i = 0; i < length; i++)
		cout << mass[i] << ' ';
	cout << endl;
}

// Создание m-последовательности из 0 и 1.
// параметры:
// mass - массив позиций единичек.
// length - длина массива.
// m - длина последовательности.
void CreateSequence(int* mass, int length, int m)
{
	int* result = new int[m]; // результирующий массив последовательности

	for (int i = 0; i < m; i++)
		result[i] = 0; // заполняем его нулями

	// раставялем единички на места, указанные в массиве mass
	for (int i = 0; i < length; i++)
	{
		result[mass[i]] = 1;
	}
	Print(result, m); // выводим результат
}

// Генерация сочетаний без повторения из m по n.
// Служит для генерации позиций числа 1 в конечной последовательности.
// параметры:
// k - текущий шаг генерации.
// n - кол-во мест, на которые можно разместить чило 1.
// A - результирующий массив позиций единичек.
// dop - массив, используемый для проверки, задействавано ли число в строящейся последовательности или нет (чтобы не было повторений).
// m - длина последовательности (кол-во всех возможных мест для размещения числа 1).
void Sochet_BP(int k, int n, int* A, bool* dop, int m)
{
	if (k == n) // если последовательность мест для 1 уже построена то
	{
		// Print(A, n);
		CreateSequence(A, n, m); // перейти для генерации результуру.щей последовательности
	}
	else
	{
		int t = 0;
		if (k <= 0)
			t = 0;
		else
			t = A[k - 1] + 1;

		for (int y = t; y < m; y++)
		{
			if (dop[y])
			{
				A[k] = y;
				dop[y] = false;
				Sochet_BP(k + 1, n, A, dop, m);
				dop[y] = true;
			}
		}
	}
}